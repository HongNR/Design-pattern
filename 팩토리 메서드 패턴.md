팩토리 메서드 패턴
=
> 팩토리 메서드 패턴은 부모 클래스에 객체를 생성하는 인터페이스를 정의하지만, 실제 생성될 객체의 유형은 자식 클래스에서 결정하도록 하는 생성 디자인 패턴입니다.  
> 이는 객체 생성 로직을 캡슐화하고, 시스템이 새로운 유형의 객체를 생성할 때 기존 코드를 수정하지 않고 확장할 수 있도록 유연성을 제공합니다.  

<br>

## 문제점   
_물류 관리 앱 개발 상황을 가정_   
  
앱의 초기 버전은 트럭 운송만을 처리하도록 설계되었으며, 대부분의 로직이 Truck 클래스에 집중되어 있었습니다.   
앱이 인기를 얻으면서 해상 물류 기능을 추가해달라는 요청이 쇄도하기 시작했습니다. 하지만 기존 코드가 Truck 클래스에 강하게 결합되어 있어, Ship (선박) 클래스를 추가하는 것이 간단하지 않습니다.   
  
이러한 상황은 다음과 같은 문제점을 야기합니다:   
- **높은 결합도 (High Coupling)** : 현재 대부분의 코드가 Truck 클래스에 직접적으로 의존하고 있습니다. Ship 클래스를 추가하려면, Truck과 관련된 기존 코드 베이스 전체를 변경해야 할 수 있습니다.   
- **유연성 부족 및 확장성 저하** : 차후에 다른 유형의 운송 수단(예: 비행기, 기차)을 추가하게 되면, 또다시 코드 베이스 전체를 변경해야 할 가능성이 큽니다. 이는 새로운 기능을 추가할 때마다 많은 수고와 잠재적인 버그를 초래합니다.   
- **복잡한 조건문** : 운송 수단 객체의 클래스에 따라 앱의 행동이 달라지도록 구현할 경우, if-else if 또는 switch-case와 같은 조건문이 과도하게 증가하여 코드가 매우 복잡하고 읽기 어려워집니다. 이는 유지보수성을 크게 떨어뜨립니다.   
결론적으로, 현재의 디자인은 새로운 운송 수단 타입을 쉽게 추가하거나 변경하기 어렵게 만들며, 시스템의 유지보수성과 확장성에 심각한 문제를 초래합니다.   
  
<br>

## 해결책
팩토리 메서드 패턴은 객체 생성을 위한 new 연산자의 직접 호출을 팩토리 메서드로 대체할 것을 제안합니다. 객체는 여전히 팩토리 메서드 내부에서 new 연산자를 통해 생성됩니다. 이 팩토리 메서드에서 반환되는 객체를 **제품(Product)** 이라고 부릅니다.  
> 팩토리 메서드 패턴에서 팩토리 메서드는 클래스의 생성자(Constructor)가 아닙니다.   
> 개발자가 직접 정의하는 새로운 일반 메서드입니다. 일반적으로 createTransport() 등과 같이 객체를 생성하고 반환하는 역할을 수행하는 메서드입니다.   
  
![factory-method image](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1.png)

핵심은 자식 클래스들이 이 팩토리 메서드를 오버라이딩(재정의)하여 어떤 유형의 제품을 반환할지 변경할 수 있다는 점입니다. 겉보기에는 단순히 생성자 호출을 옮긴 것처럼 보이지만, 이를 통해 자식 클래스에서 생성될 객체의 종류를 제어할 수 있게 됩니다.  

이 패턴을 사용하려면 몇 가지 제약 사항이 있습니다:  
- 모든 제품은 공통 인터페이스나 추상 클래스를 따라야 합니다. 예를 들어, Truck과 Ship 클래스가 모두 Transport라는 공통 인터페이스를 구현해야 합니다. 이 Transport 인터페이스는 deliver()와 같은 공통 메서드를 선언합니다.  
- 각 자식 클래스는 이 공통 메서드를 자신의 방식대로 구현합니다. 예를 들어 Truck은 도로 운송을, Ship은 해상 운송을 구현합니다.  
- Logistics와 같은 부모 클래스의 팩토리 메서드(createTransport())는 이 공통 인터페이스(Transport)를 반환 타입으로 선언해야 합니다.  

팩토리 메서드를 호출하는 코드를 클라이언트 코드라고 합니다. 클라이언트 코드는 다양한 자식 클래스가 실제로 어떤 종류의 제품(Truck 또는 Ship)을 반환하는지 알 필요가 없습니다. 클라이언트 코드는 모든 제품을 추상적인 Transport 객체로 간주하며, deliver() 메서드가 존재한다는 것만 알면 됩니다. 이 메서드가 내부적으로 어떻게 동작하는지는 클라이언트에게 중요하지 않습니다.  

이렇게 함으로써 클라이언트 코드는 특정 제품 클래스에 묶이지 않고, 새로운 제품 클래스가 추가되더라도 기존 코드를 수정할 필요 없이 유연하게 확장할 수 있게 됩니다.  

<br>

## 구조
![factory-method image](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)

<br>

## 의사코드
_시나리오: 다중 운영 체제 UI 렌더링_  

![factory-method image](https://refactoring.guru/images/patterns/diagrams/factory-method/example.png)  

기초 Dialog 클래스는 다양한 UI 요소들을 사용하여 대화 상자를 렌더링합니다. 이 UI 요소들은 운영 체제(OS)마다 시각적으로 다를 수 있지만, 기능적으로는 일관되어야 합니다. 예를 들어, Windows의 버튼이든 Linux의 버튼이든 모두 클릭 기능을 제공해야 합니다. 

팩토리 메서드 패턴을 적용하면, 각 OS별로 대화 상자 로직을 반복해서 재작성할 필요가 없습니다.


### buttons
#### buttons/Button.java: 공통 제품 인터페이스

```java
package refactoring.buttons;

/**
 * Common interface for all buttons.
 */
public interface Button {
    void render();
    void onClick();
}
```

#### buttons/HtmlButton.java: 구상 제품
```java
package refactoring.buttons;

/**
 * HTML button implementation.
 */
public class HtmlButton implements Button {

    public void render() {
        System.out.println("<button>Test Button</button>");
        onClick();
    }

    public void onClick() {
        System.out.println("Click! Button says - 'Hello World!'");
    }
}
```

#### buttons/WindowsButton.java: 또 하나의 구상 제품
```java
package refactoring.buttons;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Windows button implementation.
 */
public class WindowsButton implements Button {
    JPanel panel = new JPanel();
    JFrame frame = new JFrame();
    JButton button;

    public void render() {
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JLabel label = new JLabel("Hello World!");
        label.setOpaque(true);
        label.setBackground(new Color(235, 233, 126));
        label.setFont(new Font("Dialog", Font.BOLD, 44));
        label.setHorizontalAlignment(SwingConstants.CENTER);
        panel.setLayout(new FlowLayout(FlowLayout.CENTER));
        frame.getContentPane().add(panel);
        panel.add(label);
        onClick();
        panel.add(button);

        frame.setSize(320, 200);
        frame.setVisible(true);
        onClick();
    }

    public void onClick() {
        button = new JButton("Exit");
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                frame.setVisible(false);
                System.exit(0);
            }
        });
    }
}
```

### factory
#### factory/Dialog.java: 기초 크리에이터
```java
package refactoring.factory;

import refactoring.buttons.Button;

/**
 * Base factory class. Note that "factory" is merely a role for the class. It
 * should have some core business logic which needs different products to be
 * created.
 */
public abstract class Dialog {

    public void renderWindow() {
        // ... other code ...

        Button okButton = createButton();
        okButton.render();
    }

    /**
     * Subclasses will override this method in order to create specific button
     * objects.
     */
    public abstract Button createButton();
}
```

#### factory/HtmlDialog.java: 구상 크리에이터
```java
package refactoring.factory;

import refactoring.buttons.Button;
import refactoring.buttons.HtmlButton;

/**
 * HTML Dialog will produce HTML buttons.
 */
public class HtmlDialog extends Dialog {

    @Override
    public Button createButton() {
        return new HtmlButton();
    }
}
```

#### factory/WindowsDialog.java: 또 하나의 구상 크리에이터
```java
package refactoring.factory;

import refactoring.buttons.Button;
import refactoring.buttons.WindowsButton;

/**
 * Windows Dialog will produce Windows buttons.
 */
public class WindowsDialog extends Dialog {

    @Override
    public Button createButton() {
        return new WindowsButton();
    }
}
```

#### Demo.java: 클라이언트 코드

```java
package refactoring.example;

import refactoring.factory.Dialog;
import refactoring.factory.HtmlDialog;
import refactoring.factory.WindowsDialog;

/**
 * Demo class. Everything comes together here.
 */
public class Demo {
    private static Dialog dialog;

    public static void main(String[] args) {
        configure();
        runBusinessLogic();
    }

    /**
     * The concrete factory is usually chosen depending on configuration or
     * environment options.
     */
    static void configure() {
        if (System.getProperty("os.name").equals("Windows 10")) {
            dialog = new WindowsDialog();
        } else {
            dialog = new HtmlDialog();
        }
    }

    /**
     * All of the client code should work with factories and products through
     * abstract interfaces. This way it does not care which factory it works
     * with and what kind of product it returns.
     */
    static void runBusinessLogic() {
        dialog.renderWindow();
    }
}
```

<br>

## 적용
- 팩토리 메서드는 당신의 코드가 함께 작동해야 하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우 사용하세요.  
- 팩토리 메서드는 당신의 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법을 제공하고 싶을 때 사용하세요.  
- 팩토리 메서드는 기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때 사용하세요.  

<br>

## 장단점
- 크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있습니다.  
- 단일 책임 원칙. 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리할 수 있습니다.  
- 개방/폐쇄 원칙. 당신은 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있습니다.  

- 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있습니다. 가장 좋은 방법은 크리에이터 클래스들의 기존 계층구조에 패턴을 도입하는 것입니다.