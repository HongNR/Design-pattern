팩토리 메서드 패턴
=
> 팩토리 메서드 패턴은 부모 클래스에 객체를 생성하는 인터페이스를 정의하지만, 실제 생성될 객체의 유형은 자식 클래스에서 결정하도록 하는 생성 디자인 패턴입니다.  
> 이는 객체 생성 로직을 캡슐화하고, 시스템이 새로운 유형의 객체를 생성할 때 기존 코드를 수정하지 않고 확장할 수 있도록 유연성을 제공합니다.  

<br>

## 문제점   
_물류 관리 앱 개발 상황을 가정_   
  
앱의 초기 버전은 트럭 운송만을 처리하도록 설계되었으며, 대부분의 로직이 Truck 클래스에 집중되어 있었습니다.   
앱이 인기를 얻으면서 해상 물류 기능을 추가해달라는 요청이 쇄도하기 시작했습니다. 하지만 기존 코드가 Truck 클래스에 강하게 결합되어 있어, Ship (선박) 클래스를 추가하는 것이 간단하지 않습니다.   
  
이러한 상황은 다음과 같은 문제점을 야기합니다:   
- **높은 결합도 (High Coupling)** : 현재 대부분의 코드가 Truck 클래스에 직접적으로 의존하고 있습니다. Ship 클래스를 추가하려면, Truck과 관련된 기존 코드 베이스 전체를 변경해야 할 수 있습니다.   
- **유연성 부족 및 확장성 저하** : 차후에 다른 유형의 운송 수단(예: 비행기, 기차)을 추가하게 되면, 또다시 코드 베이스 전체를 변경해야 할 가능성이 큽니다. 이는 새로운 기능을 추가할 때마다 많은 수고와 잠재적인 버그를 초래합니다.   
- **복잡한 조건문** : 운송 수단 객체의 클래스에 따라 앱의 행동이 달라지도록 구현할 경우, if-else if 또는 switch-case와 같은 조건문이 과도하게 증가하여 코드가 매우 복잡하고 읽기 어려워집니다. 이는 유지보수성을 크게 떨어뜨립니다.   
결론적으로, 현재의 디자인은 새로운 운송 수단 타입을 쉽게 추가하거나 변경하기 어렵게 만들며, 시스템의 유지보수성과 확장성에 심각한 문제를 초래합니다.   
  
<br>

## 해결책
팩토리 메서드 패턴은 객체 생성을 위한 new 연산자의 직접 호출을 팩토리 메서드로 대체할 것을 제안합니다. 객체는 여전히 팩토리 메서드 내부에서 new 연산자를 통해 생성됩니다. 이 팩토리 메서드에서 반환되는 객체를 **제품(Product)** 이라고 부릅니다.  
> 팩토리 메서드 패턴에서 팩토리 메서드는 클래스의 생성자(Constructor)가 아닙니다.   
> 개발자가 직접 정의하는 새로운 일반 메서드입니다. 일반적으로 createTransport() 등과 같이 객체를 생성하고 반환하는 역할을 수행하는 메서드입니다.   
  
![factory-method image](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1.png)

핵심은 자식 클래스들이 이 팩토리 메서드를 오버라이딩(재정의)하여 어떤 유형의 제품을 반환할지 변경할 수 있다는 점입니다. 겉보기에는 단순히 생성자 호출을 옮긴 것처럼 보이지만, 이를 통해 자식 클래스에서 생성될 객체의 종류를 제어할 수 있게 됩니다.  

이 패턴을 사용하려면 몇 가지 제약 사항이 있습니다:  
- 모든 제품은 공통 인터페이스나 추상 클래스를 따라야 합니다. 예를 들어, Truck과 Ship 클래스가 모두 Transport라는 공통 인터페이스를 구현해야 합니다. 이 Transport 인터페이스는 deliver()와 같은 공통 메서드를 선언합니다.  
- 각 자식 클래스는 이 공통 메서드를 자신의 방식대로 구현합니다. 예를 들어 Truck은 도로 운송을, Ship은 해상 운송을 구현합니다.  
- Logistics와 같은 부모 클래스의 팩토리 메서드(createTransport())는 이 공통 인터페이스(Transport)를 반환 타입으로 선언해야 합니다.  

팩토리 메서드를 호출하는 코드를 클라이언트 코드라고 합니다. 클라이언트 코드는 다양한 자식 클래스가 실제로 어떤 종류의 제품(Truck 또는 Ship)을 반환하는지 알 필요가 없습니다. 클라이언트 코드는 모든 제품을 추상적인 Transport 객체로 간주하며, deliver() 메서드가 존재한다는 것만 알면 됩니다. 이 메서드가 내부적으로 어떻게 동작하는지는 클라이언트에게 중요하지 않습니다.  

이렇게 함으로써 클라이언트 코드는 특정 제품 클래스에 묶이지 않고, 새로운 제품 클래스가 추가되더라도 기존 코드를 수정할 필요 없이 유연하게 확장할 수 있게 됩니다.  


<br>

## 의사코드
_시나리오: 다중 운영 체제 UI 렌더링_  

![factory-method image](https://refactoring.guru/images/patterns/diagrams/factory-method/example.png)  

기초 Dialog 클래스는 다양한 UI 요소들을 사용하여 대화 상자를 렌더링합니다. 이 UI 요소들은 운영 체제(OS)마다 시각적으로 다를 수 있지만, 기능적으로는 일관되어야 합니다. 예를 들어, Windows의 버튼이든 Linux의 버튼이든 모두 클릭 기능을 제공해야 합니다. 

팩토리 메서드 패턴을 적용하면, 각 OS별로 대화 상자 로직을 반복해서 재작성할 필요가 없습니다.


<br>

## 예시: oauth
#### 공통 제품 인터페이스

```java
package com.TastUtopia.oauth.authprovider;

public interface SocialAuthProvider {
    User execute(OAuth2User oAuth2User);
}
```   
##### OAuth 인증 제공자들이 공통적으로 수행해야 할 execute() 메서드를 정의하는 **추상 제품(Abstract Product)**입니다.   

<br>

#### 구상 제품
```java
package com.TastUtopia.oauth.authprovider;

public class KakaoAuthProvider implements SocialAuthProvider {

    private final OAuth2User oAuth2User;

    public KakaoAuthProvider(OAuth2User oAuth2User) {
        this.oAuth2User = oAuth2User;
    }

    @Override
    public User execute(OAuth2User oAuth2User) {
        String userId = "kakao_" + oAuth2User.getAttributes().get("id");
        Map<String, Object> properties = (Map<String, Object>) oAuth2User.getAttributes().get("properties");
        String email = "email@emil.com";

        return new User(userId, email, (String) properties.get("nickname"));
    }
}
```   
##### SocialAuthProvider 인터페이스를 구현하며, 카카오 OAuth 인증에 특화된 로직을 담고 있는 **구체적인 제품(Concrete Product)**입니다.   

<br>

### factory
#### 기초 크리에이터 / 구상 크리에이터
```java
package com.TastUtopia.oauth;

// 팩토리 클래스
public class SocialAuthProviderFactory {

    private final Map<String, Function<OAuth2User, SocialAuthProvider>> providerMap = new HashMap<>();

    public SocialAuthProviderFactory() {
        providerMap.put("naver", NaverAuthProvider::new);
        providerMap.put("google", GoogleAuthProvider::new);
        providerMap.put("kakao", KakaoAuthProvider::new);
        providerMap.put("facebook", FacebookAuthProvider::new);
    }

    // 팩토리 메서드
    public SocialAuthProvider getProvider(String providerName, OAuth2User oAuth2User) {
        Function<OAuth2User, SocialAuthProvider> creator = providerMap.get(providerName);
        if (creator == null) {
            throw new IllegalArgumentException("지원하지 않는 OAuth2 provider: " + providerName);
        }

        return creator.apply(oAuth2User);
    }
}
```   
##### 이 클래스가 **팩토리(Factory)**의 역할을 수행합니다. 내부적으로 providerMap을 사용하여 다양한 SocialAuthProvider 구현체들의 생성자 레퍼런스를 저장합니다.   
##### getProvider(String providerName, OAuth2User oAuth2User) 메서드가 팩토리 메서드입니다. 이 메서드는 주어진 providerName에 따라 적절한 SocialAuthProvider 객체를 동적으로 생성하여 반환합니다.

<br>

#### 클라이언트 코드

```java
package com.TastUtopia.service.oauth2;

public class OAuth2UserService extends DefaultOAuth2UserService {

    private final UserSpringJpaRepository userSpringJpaRepository;
    private final SocialAuthProviderFactory providerFactory;

    @Override
    public OAuth2User loadUser(OAuth2UserRequest request) throws OAuth2AuthenticationException {
        OAuth2User oAuth2User = super.loadUser(request);
        String oauth2ClientName = request.getClientRegistration().getClientName();

        // ...

        // OAuth 제공자
        SocialAuthProvider provider = providerFactory.getProvider(oauth2ClientName, oAuth2User);
        User oauthUser = provider.execute(oAuth2User);

        // ...
    }
}
```
##### providerFactory.getProvider(oauth2ClientName, oAuth2User)를 호출하여, SocialAuthProviderFactory로부터 특정 SocialAuthProvider 객체를 주입받습니다.
##### 이후 주입받은 provider 객체의 execute() 메서드를 호출하여 OAuth 인증 로직을 실행합니다. 클라이언트 코드는 NaverAuthProvider인지 KakaoAuthProvider인지 구체적인 구현체에 대해 전혀 알지 못하고, 오직 SocialAuthProvider 인터페이스를 통해 작업합니다.

<br>

## 적용
### 팩토리 메서드는 당신의 코드가 함께 작동해야 하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우 사용하세요.  

#### 팩토리 메서드란?
- 어떤 객체를 만들지 미리 정확히 모를 때 사용하는 방법입니다.
- 객체 생성 코드와 그 객체를 사용하는 코드를 분리해줍니다.   

#### 왜 좋을까?
- 새 제품(객체)을 추가해도 기존 코드를 거의 안 건드려도 됩니다.   
- 만들기만 하면 끝!   
→ 새 클래스를 만들고, 거기서 팩토리 메서드만 오버라이딩(재정의) 하면 됩니다.   

#### 예시
- 기존 코드는 ‘음료’를 만들지만, 어떤 음료(콜라, 사이다, 커피)는 몰라요.   
→ 팩토리 메서드를 써서 “콜라 만들기”, “커피 만들기”를 나중에 정하면   
→ 나중에 새 음료 추가하기가 쉬워요.   

<br>

### 팩토리 메서드는 당신의 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법을 제공하고 싶을 때 사용하세요.  

#### 언제 팩토리 메서드를 써야 할까?
- 프레임워크나 라이브러리의 기본 기능을 확장하고 싶을 때!   
(예: 기본 버튼 대신 "내가 만든 버튼"을 쓰고 싶을 때)   

#### 예시
1. 오픈소스 UI 프레임워크를 사용하는데, 기본으로는 사각형 버튼(Button) 만 제공됨.
2. 나는 앱에 둥근 버튼(RoundButton) 을 쓰고 싶음.
3. 그래서 Button을 상속한 RoundButton 클래스를 직접 만듦.
4. 근데 프레임워크는 여전히 기본 Button만 씀.

#### 해결 방법   
1. 프레임워크의 버튼 생성 코드를 createButton() 같은 팩토리 메서드 하나로 모음.
2. 내가 만든 UIWithRoundButtons 클래스에서 이 메서드를 오버라이딩(재정의) 해서   
→ RoundButton을 반환하도록 바꿈.
3. 이제 기존 UIFramework 대신   
→ UIWithRoundButtons 를 사용하면   
→ 프레임워크가 내가 만든 둥근 버튼을 사용하게 됨!   


### 팩토리 메서드는 기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때 사용하세요.  

#### 언제 팩토리 메서드를 써야 할까?
- 매번 새 객체를 만들지 말고, 기존 객체를 재사용하고 싶을 때!   
(예: DB 연결, 네트워크, 파일 시스템 같은 무거운 리소스를 쓸 때)   

#### 왜 이렇게 할까?
- 무거운 객체를 계속 새로 만들면 → 리소스 낭비 + 성능 저하
- 그래서 이미 만든 객체를 재활용하는 게 유리함!

#### 객체 재사용 흐름
1. 객체들을 모아두는 저장소(예: 풀) 를 만든다.   
2. 누군가 객체 요청하면:   
    풀 안에 남은(free) 객체가 있으면 → 그걸 반환   
    없으면 → 새 객체 생성 → 풀에 저장 후 반환   
3. 이 흐름을 한 곳에서만 관리하고 싶다.   
    중복 코드 없이, 깔끔하게!

#### 그런데 생성자는 이걸 못 함!   
- 생성자(new)는 무조건 새 객체만 만들어야 함.   
- 기존 객체를 돌려줄 수가 없음!   

#### 해결책? → 팩토리 메서드!   
- 팩토리 메서드를 사용하면   
→ 새 객체를 만들지 말고   
→ 기존 객체를 찾아서 재사용하는 로직을   
→ 하나의 메서드에 깔끔히 모을 수 있음!   


<br>

## 장단점
- 크리에이터와 구상 제품들이 단단하게 결합되지 않도록 할 수 있습니다.  
- 단일 책임 원칙. 제품 생성 코드를 프로그램의 한 위치로 이동하여 코드를 더 쉽게 유지관리할 수 있습니다.  
- 개방/폐쇄 원칙. 당신은 기존 클라이언트 코드를 훼손하지 않고 새로운 유형의 제품들을 프로그램에 도입할 수 있습니다.  

- 패턴을 구현하기 위해 많은 새로운 자식 클래스들을 도입해야 하므로 코드가 더 복잡해질 수 있습니다. 가장 좋은 방법은 크리에이터 클래스들의 기존 계층구조에 패턴을 도입하는 것입니다.